const FLOAT = new Float64Array(1);
const FLOAT_BYTES = new Uint8Array(FLOAT.buffer, 0, 8);

/**
 * Number parsing and serializing utilities.
 * @internal
 */
export const NumberUtils = {
  // Reads a little-endian 32-bit integer from source
  getInt32LE(source: Uint8Array, offset: number): number {
    let value = 0;
    for (let i = 0; i < 4; i++) {
      value += source[offset + i] << (i * 8);
    }
    return value;
  },

  // Reads a little-endian 32-bit unsigned integer from source
  getUint32LE(source: Uint8Array, offset: number): number {
    return this.getInt32LE(source, offset) & 0xffffffff;
  },

  // Reads a big-endian 32-bit integer from source
  getUint32BE(source: Uint8Array, offset: number): number {
    let value = 0;
    for (let i = 0; i < 4; i++) {
      value += source[offset + 3 - i] << (i * 8);
    }
    return value;
  },

  // Reads a little-endian 64-bit integer from source
  getBigInt64LE(source: Uint8Array, offset: number): bigint {
    const lo = this.getUint32LE(source, offset);
    const hi = this.getUint32LE(source, offset + 4);

    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  },

  // Reads a little-endian 64-bit float from source
  getFloat64LE(source: Uint8Array, offset: number): number {
    FLOAT_BYTES.set(source.subarray(offset, offset + 8));
    return FLOAT[0];
  },

  // Writes a big-endian 32-bit integer to destination, can be signed or unsigned
  setInt32BE(destination: Uint8Array, offset: number, value: number): number {
    for (let i = 0; i < 4; i++) {
      destination[offset + i] = (value >>> (i * 8)) & 0xff;
    }
    return 4;
  },

  // Writes a little-endian 32-bit integer to destination, can be signed or unsigned
  setInt32LE(destination: Uint8Array, offset: number, value: number): number {
    for (let i = 0; i < 4; i++) {
      destination[offset + i] = value & 0xff;
      value >>>= 8;
    }
    return 4;
  },

  // Write a little-endian 64-bit integer to source
  setBigInt64LE(destination: Uint8Array, offset: number, value: bigint): number {
    const mask32bits = BigInt(0xffffffff);

    let lo = Number(value & mask32bits);
    for (let i = 0; i < 4; i++) {
      destination[offset + i] = lo & 0xff;
      lo >>>= 8;
    }

    let hi = Number((value >> BigInt(32)) & mask32bits);
    for (let i = 0; i < 4; i++) {
      destination[offset + 4 + i] = hi & 0xff;
      hi >>>= 8;
    }

    return 8;
  },

  // Writes a little-endian 64-bit float to destination
  setFloat64LE(destination: Uint8Array, offset: number, value: number): number {
    FLOAT[0] = value;
    for (let i = 0; i < 8; i++) {
      destination[offset + i] = FLOAT_BYTES[i];
    }
    return 8;
  }
};
