'use strict';

const fill = require('fill-range');
const utils = require('./utils');

const compile = (ast, options = { escapeInvalid: true }) => {
  const walk = (node, parent = {}) => {
    const isInvalidBlock = utils.isInvalidBrace(parent);
    const isInvalidNode = node.invalid === true && options.escapeInvalid === true;
    const isInvalid = isInvalidBlock || isInvalidNode;
    const prefix = isInvalid ? `\\` : '';
    let output = '';

    // Handle open and close braces
    if (node.isOpen) {
      return prefix + node.value;
    }
    if (node.isClose) {
      return prefix + node.value;
    }

    // Handle open and close parentheses
    if (node.type === 'open') {
      return isInvalid ? (prefix + node.value) : '(';
    }

    if (node.type === 'close') {
      return isInvalid ? (prefix + node.value) : ')';
    }

    // Handle commas
    if (node.type === 'comma') {
      return node.prev && node.prev.type === 'comma' ? '' : (isInvalid ? node.value : '|');
    }

    // Handle nodes with values
    if (node.value) {
      return node.value;
    }

    // Handle nodes with ranges
    if (node.nodes && node.ranges > 0) {
      try {
        const args = utils.reduce(node.nodes);
        const range = fill(...args, { ...options, wrap: false, toRegex: true });

        if (range.length !== 0) {
          return args.length > 1 && range.length > 1 ? `(${range})` : range;
        }
      } catch (e) {
        console.error(`Error generating range for node: ${JSON.stringify(node)}`);
        throw e;
      }
    }

    // Handle nodes with child nodes
    if (node.nodes) {
      for (const child of node.
