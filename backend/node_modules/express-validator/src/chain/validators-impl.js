"use strict";

import { Validator } from "validator";
import { CustomValidation, StandardValidation, ContextItem } from "../context-items";

export class ValidatorsImpl {
    private builder: any;
    private chain: any;
    private lastValidator: ContextItem;
    private negateNext: boolean;

    constructor(builder, chain) {
        this.builder = builder;
        this.chain = chain;
        this.negateNext = false;
    }

    /**
     * Adds a new validation item to the builder.
     * @param item - The validation item to add.
     */
    public addItem(item: ContextItem): this {
        this.builder.addItem(item);
        this.lastValidator = item;
        this.negateNext = false;
        return this.chain;
    }

    /**
     * Negates the next validation.
     */
    public not(): this {
        this.negateNext = true;
        return this.chain;
    }

    /**
     * Sets the message for the last validation.
     * @param message - The message to set.
     */
    public withMessage(message: string): this {
        this.lastValidator.message = message;
        return this.chain;
    }

    /**
     * Adds a custom validation.
     * @param validator - The custom validation function.
     */
    public custom(validator: (value: any) => boolean): this {
        return this.addItem(new CustomValidation(validator, this.negateNext));
    }

    /**
     * Checks if the value exists.
     * @param options - The options for the validation.
     */
    public exists(options: { checkFalsy?: boolean; checkNull?: boolean; values?: string } = {}): this {
        const validator = (value: any) => {
            if (options.checkFalsy || options.values === "falsy") {
                return !!value;
            } else if (options.checkNull || options.values === "null") {
                return value != null;
            } else {
                return value !== undefined;
            }
        };

        return this.custom(validator);
    }

    /**
     * Checks if the value is an array.
     * @param options - The options for the validation.
     */
    public isArray(options: { min?: number; max?: number } = {}): this {
        return this.custom((value: any) => Array.isArray(value) &&
            (typeof options.min === "undefined" || value.length >= options.min) &&
            (typeof options.max === "undefined" || value.length <= options.max));
    }

    /**
     * Checks if the value is an object.
     * @param options - The options for the validation.
     */
    public isObject(options: { strict?: boolean } = { strict: true }): this {
        return this.custom((value: any) => typeof value === "object" &&
            (options.strict == null || options.strict ? value !== null && !Array.isArray(value) : true));
    }

    /**
     * Checks if the value is a string.
     */
    public isString(): this {
        return this.custom((value: any) => typeof value === "string");
    }

    /**
     * Checks if the value is not empty.
     * @param options - The options for the validation.
     */
    public notEmpty(options: { min?: number } = {}): this {
        this.not();
        return this.isEmpty(options);
    }

    /**
     * Adds a standard validation.
     * @param validator - The standard validation function.
     * @param options - The options for the validation.
     */
    private addStandardValidation(
        validator: (value: any, ...options: any[]) => boolean,
        ...options: any[]
    ): this {
        return this.addItem(new StandardValidation(validator, this.negateNext, options));
    }

    // ... rest of the methods

}

export default ValidatorsImpl;
