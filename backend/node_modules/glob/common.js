const fs = require("fs");
const path = require("path");
const minimatch = require("minimatch");
const isAbsolute = require("path-is-absolute");
const Minimatch = minimatch.Minimatch;

function alphasort(a, b) {
  return a.localeCompare(b, "en");
}

function setupIgnores(self, options) {
  self.ignore = options.ignore || [];

  if (!Array.isArray(self.ignore)) {
    self.ignore = [self.ignore];
  }

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap);
  }
}

function ignoreMap(pattern) {
  var gmatcher = null;
  if (pattern.slice(-3) === "/**") {
    var gpattern = pattern.replace(/(\/\*\*)+$/, "");
    gmatcher = new Minimatch(gpattern, { dot: true });
  }

  return {
    matcher: new Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher,
  };
}

function setopts(self, pattern, options) {
  if (!options) {
    options = {};
  }

  if (options.matchBase && pattern.indexOf("/") === -1) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar");
    }
    pattern = "**/" + pattern;
  }

  self.silent = !!options.silent;
  self.pattern = pattern;
  self.strict = options.strict !== false;
  self.realpath = !!options.realpath;
  self.realpathCache = options.realpathCache || Object.create(null);
  self.follow = !!options.follow;
  self.dot = !!options.dot;
  self.mark = !!options.mark;
  self.nodir = !!options.nodir;
  if (self.nodir) {
    self.mark = true;
  }
  self.sync = !!options.sync;
  self.nounique = !!options.nounique;
  self.nonull = !!options.nonull;
  self.nosort = !!options.nosort;
  self.nocase = !!options.nocase;
  self.stat = !!options.stat;
  self.noprocess = !!options.noprocess;
  self.absolute = !!options.absolute;
  self.fs = options.fs || fs;

  self.maxLength = options.maxLength || Infinity;
  self.cache = options.cache || Object.create(null);
  self.statCache = options.statCache || Object.create(null);
  self.symlinks = options.symlinks || Object.create(null);

  setupIgnores(self, options);

  self.changedCwd = false;
  const cwd = process.cwd();
  if (!this.ownProp(options, "cwd")) {
    self.cwd = cwd;
  } else {
    self.cwd = path.resolve(options.cwd);
    self.changedCwd = self.cwd !== cwd;
  }

  self.root = options.root || path.resolve(self.cwd, "/");
  self.root = path.resolve(self.root);
  if (process.platform === "win32") {
    self.root = self.root.replace(/\\/g, "/");
  }

  self.cwdAbs =
    isAbsolute(self.cwd) || self.cwd === ""
      ? self.cwd
      : path.resolve(self.cwd);
  try {
    self.cwdAbs = path.resolve(self.cwdAbs);
  } catch (err) {
    if (self.silent) {
      return;
    }
    throw err;
  }
  if (process.platform === "win32") {
    self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
  }

  self.nomount = !!options.nomount;

  const validOptions = [
    "nonegate",
    "nocomment",
    "allowWindowsEscape",
  ];
  validOptions.forEach((option) => {
    if (options[option] !== undefined) {
      self.minimatch.options[option] = options[option];
    }
  });

  self.minimatch = new Minimatch(pattern, options);
  self.options = self.minimatch.options;
}

// ... rest of the code

